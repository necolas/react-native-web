{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.useIntersection = useIntersection;\n\nvar _react = require(\"react\");\n\nvar _requestIdleCallback = _interopRequireDefault(require(\"./request-idle-callback\"));\n\nvar hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection(_ref) {\n  var rootMargin = _ref.rootMargin,\n      disabled = _ref.disabled;\n  var isDisabled = disabled || !hasIntersectionObserver;\n  var unobserve = (0, _react.useRef)();\n\n  var _ref2 = (0, _react.useState)(false),\n      _ref3 = _slicedToArray(_ref2, 2),\n      visible = _ref3[0],\n      setVisible = _ref3[1];\n\n  var setRef = (0, _react.useCallback)(function (el) {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, function (isVisible) {\n        return isVisible && setVisible(isVisible);\n      }, {\n        rootMargin: rootMargin\n      });\n    }\n  }, [isDisabled, rootMargin, visible]);\n  (0, _react.useEffect)(function () {\n    if (!hasIntersectionObserver) {\n      if (!visible) (0, _requestIdleCallback[\"default\"])(function () {\n        return setVisible(true);\n      });\n    }\n  }, [visible]);\n  return [setRef, visible];\n}\n\nfunction observe(element, callback, options) {\n  var _createObserver = createObserver(options),\n      id = _createObserver.id,\n      observer = _createObserver.observer,\n      elements = _createObserver.elements;\n\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements[\"delete\"](element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers[\"delete\"](id);\n    }\n  };\n}\n\nvar observers = new Map();\n\nfunction createObserver(options) {\n  var id = options.rootMargin || '';\n  var instance = observers.get(id);\n\n  if (instance) {\n    return instance;\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  });\n  return instance;\n}","map":{"version":3,"sources":["../../client/use-intersection.tsx"],"names":["hasIntersectionObserver","isDisabled","disabled","unobserve","setRef","el","observe","isVisible","setVisible","rootMargin","createObserver","elements","observer","observers","id","options","instance","entries","entry","callback"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react'\nimport requestIdleCallback from './request-idle-callback'\n\ntype UseIntersectionObserverInit = Pick<IntersectionObserverInit, 'rootMargin'>\ntype UseIntersection = { disabled?: boolean } & UseIntersectionObserverInit\ntype ObserveCallback = (isVisible: boolean) => void\ntype Observer = {\n  id: string\n  observer: IntersectionObserver\n  elements: Map<Element, ObserveCallback>\n}\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined'\n\nexport function useIntersection<T extends Element>({\n  rootMargin,\n  disabled,\n}: UseIntersection): [(element: T | null) => void, boolean] {\n  const isDisabled: boolean = disabled || !hasIntersectionObserver\n\n  const unobserve = useRef<Function>()\n  const [visible, setVisible] = useState(false)\n\n  const setRef = useCallback(\n    (el: T | null) => {\n      if (unobserve.current) {\n        unobserve.current()\n        unobserve.current = undefined\n      }\n\n      if (isDisabled || visible) return\n\n      if (el && el.tagName) {\n        unobserve.current = observe(\n          el,\n          (isVisible) => isVisible && setVisible(isVisible),\n          { rootMargin }\n        )\n      }\n    },\n    [isDisabled, rootMargin, visible]\n  )\n\n  useEffect(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) requestIdleCallback(() => setVisible(true))\n    }\n  }, [visible])\n\n  return [setRef, visible]\n}\n\nfunction observe(\n  element: Element,\n  callback: ObserveCallback,\n  options: UseIntersectionObserverInit\n): () => void {\n  const { id, observer, elements } = createObserver(options)\n  elements.set(element, callback)\n\n  observer.observe(element)\n  return function unobserve(): void {\n    elements.delete(element)\n    observer.unobserve(element)\n\n    // Destroy observer when there's nothing left to watch:\n    if (elements.size === 0) {\n      observer.disconnect()\n      observers.delete(id)\n    }\n  }\n}\n\nconst observers = new Map<string, Observer>()\nfunction createObserver(options: UseIntersectionObserverInit): Observer {\n  const id = options.rootMargin || ''\n  let instance = observers.get(id)\n  if (instance) {\n    return instance\n  }\n\n  const elements = new Map<Element, ObserveCallback>()\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n      const callback = elements.get(entry.target)\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0\n      if (callback && isVisible) {\n        callback(isVisible)\n      }\n    })\n  }, options)\n\n  observers.set(\n    id,\n    (instance = {\n      id,\n      observer,\n      elements,\n    })\n  )\n  return instance\n}\n"]},"metadata":{},"sourceType":"script"}